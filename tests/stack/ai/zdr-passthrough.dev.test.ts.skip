// SPDX-License-Identifier: LicenseRef-PolyForm-Shield-1.0.0
// SPDX-FileCopyrightText: 2025 Cogni-DAO

/**
 * Module: `@tests/stack/ai/zdr-passthrough.stack`
 * Purpose: Verify OpenRouter ZDR (Zero Data Retention) flag is passed through full app path.
 * Scope: Tests app → LiteLLM → OpenRouter path for ZDR-enabled models. Does not test fake adapters.
 * Invariants: ZDR-enabled model requests must include provider.zdr=true in LiteLLM outgoing payload.
 * Side-effects: IO (HTTP requests, docker logs inspection)
 * Notes: Requires real adapters (APP_ENV !== 'test') and LiteLLM debug logging enabled.
 *        Run with: docker compose -f ... -f tests/stack/_infra/docker-compose.zdr-debug.yml up -d
 * Links: platform/infra/services/runtime/configs/litellm.config.yaml, docs/TESTING.md
 * @public
 */

import { execSync } from "node:child_process";
import { randomUUID } from "node:crypto";
import { seedAuthenticatedUser } from "@tests/_fixtures/auth/db-helpers";
import { NextRequest } from "next/server";
import { describe, it, vi } from "vitest";
import { getSeedDb } from "@tests/_fixtures/db/seed-client";
import { getSessionUser } from "@/app/_lib/auth/session";
import { POST as chatPOST } from "@/app/api/v1/ai/chat/route";
import { serverEnv } from "@/shared/env/server";

// Mock session
vi.mock("@/app/_lib/auth/session", () => ({
  getSessionUser: vi.fn(),
}));

/**
 * Get LiteLLM container ID by name.
 */
function getLitellmContainerId(): string | null {
  try {
    const containerId = execSync("docker ps -q -f name=litellm", {
      encoding: "utf-8",
      timeout: 5000,
    }).trim();
    return containerId || null;
  } catch {
    return null;
  }
}

/**
 * Get recent LiteLLM container logs.
 */
function getLitellmLogs(containerId: string, lines = 500): string {
  try {
    return execSync(`docker logs ${containerId} 2>&1 | tail -${lines}`, {
      encoding: "utf-8",
      timeout: 10000,
    });
  } catch {
    return "";
  }
}

describe("ZDR Passthrough", () => {
  it("LiteLLM passes provider.zdr=true for ZDR-enabled models", async () => {
    // Require real adapters (not fake adapters)
    const env = serverEnv();
    if (env.isTestMode) {
      throw new Error(
        "ZDR test requires real adapters. Start: pnpm docker:stack"
      );
    }

    // Require LiteLLM container running
    const containerId = getLitellmContainerId();
    if (!containerId) {
      throw new Error("LiteLLM container not found. Start: pnpm docker:stack");
    }

    // Arrange - Seed authenticated user with credits
    const db = getSeedDb();
    const { user } = await seedAuthenticatedUser(
      db,
      { id: randomUUID() },
      { balanceCredits: 100000 } // Enough for premium model
    );

    if (!user.walletAddress) throw new Error("walletAddress required");

    vi.mocked(getSessionUser).mockResolvedValue({
      id: user.id,
      walletAddress: user.walletAddress,
    });

    // Act - Make chat request with ZDR-enabled model (claude-sonnet-4.5)
    // Include unique marker to identify this request in logs
    const testMarker = `ZDR_TEST_${randomUUID().substring(0, 8)}`;

    const req = new NextRequest("http://localhost:3000/api/v1/ai/chat", {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({
        stateKey: randomUUID(),
        clientRequestId: randomUUID(),
        model: "claude-sonnet-4.5", // ZDR-enabled in litellm.config.yaml
        stream: false,
        messages: [
          {
            id: randomUUID(),
            role: "user",
            createdAt: new Date().toISOString(),
            content: [
              { type: "text", text: `Test ZDR passthrough [${testMarker}]` },
            ],
          },
        ],
      }),
    });

    // Send request and capture response for debugging
    const res = await chatPOST(req);
    const status = res.status;

    // Read response body to surface exceptions
    let responseBody = "";
    try {
      responseBody = await res.text();
    } catch {
      // Body might not be available
    }

    // Wait for LiteLLM to flush logs
    await new Promise((r) => setTimeout(r, 2000));

    // Get logs (2000 lines to handle busy stacks)
    const logs = getLitellmLogs(containerId, 2000);

    // Assert: logs contain our test marker
    if (!logs.includes(testMarker)) {
      throw new Error(
        `Marker "${testMarker}" not in logs. Status: ${status}. ` +
          `Body: ${responseBody.substring(0, 200)}`
      );
    }

    // Assert: ZDR flag near marker (tighter check reduces false positives)
    const markerIndex = logs.indexOf(testMarker);
    const logSlice = logs.substring(
      Math.max(0, markerIndex - 3000),
      markerIndex + 3000
    );

    const zdrPattern = /"provider"\s*:\s*\{[^}]*"zdr"\s*:\s*true/;
    if (!zdrPattern.test(logSlice)) {
      throw new Error(
        `ZDR flag not found near marker. Slice: ${logSlice.substring(0, 500)}`
      );
    }
  });
});
