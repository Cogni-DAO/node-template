// SPDX-License-Identifier: LicenseRef-PolyForm-Shield-1.0.0
// SPDX-FileCopyrightText: 2025 Cogni-DAO

/**
 * Module: `@tests/stack/ledger/collect-epoch-workflow-id.stack.test`
 * Purpose: Prove Temporal workflow-ID semantics for CollectEpochWorkflow allow multiple collection passes per epoch window.
 * Scope: Tests workflow start behavior only (not completion). Does not test workflow execution or activity logic.
 * Invariants:
 *   - The product requires daily collection within a weekly epoch (multiple runs per window)
 *   - Deterministic workflow IDs must either: (a) include run date, or (b) use ALLOW_DUPLICATE policy
 *   - This test documents the current behavior and will catch regressions on either approach
 * Side-effects: IO (Temporal gRPC)
 * Links: services/scheduler-worker/src/workflows/collect-epoch.workflow.ts, docs/spec/epoch-ledger.md
 * @internal
 */

import { WorkflowExecutionAlreadyStartedError } from "@temporalio/client";
import {
  closeTemporalClient,
  getTestTemporalClient,
} from "@tests/_fixtures/temporal/client";
import { afterAll, afterEach, describe, expect, it } from "vitest";

// ---------------------------------------------------------------------------
// Constants matching the deterministic ID pattern from the workflow
// ---------------------------------------------------------------------------

const LEDGER_TASK_QUEUE = "ledger-tasks";
const SCOPE_KEY = "test-scope";
const PERIOD_START = "2026-02-17T00:00:00.000Z";
const PERIOD_END = "2026-02-24T00:00:00.000Z";

/** The deterministic workflow ID as currently generated by the schedule sync */
const DETERMINISTIC_WORKFLOW_ID = `ledger-collect-${SCOPE_KEY}-${PERIOD_START}-${PERIOD_END}`;

/** Workflow input matching CollectEpochWorkflowInput */
const WORKFLOW_INPUT = {
  periodStart: PERIOD_START,
  periodEnd: PERIOD_END,
  scopeId: "00000000-0000-4000-8000-000000000099",
  scopeKey: SCOPE_KEY,
  weightConfig: { "github:pr_merged": 8000 },
  sources: ["github"],
  sourceRef: "Cogni-DAO/test-repo",
};

// ---------------------------------------------------------------------------
// Cleanup tracking
// ---------------------------------------------------------------------------

const startedWorkflowIds: string[] = [];

async function terminateWorkflow(workflowId: string): Promise<void> {
  try {
    const client = await getTestTemporalClient();
    const handle = client.workflow.getHandle(workflowId);
    await handle.terminate("test cleanup");
  } catch {
    // Workflow may have already completed or been terminated
  }
}

// ---------------------------------------------------------------------------
// Suite
// ---------------------------------------------------------------------------

describe("CollectEpochWorkflow ID semantics (stack)", () => {
  afterEach(async () => {
    // Terminate all workflows started during the test
    for (const id of startedWorkflowIds) {
      await terminateWorkflow(id);
    }
    startedWorkflowIds.length = 0;
  });

  afterAll(async () => {
    await closeTemporalClient();
  });

  it("first workflow start with deterministic ID succeeds", async () => {
    const client = await getTestTemporalClient();

    // Start workflow — it will sit in task queue (no worker for ledger-tasks
    // in test stack). That's fine — we only care about the start behavior.
    const handle = await client.workflow.start("CollectEpochWorkflow", {
      workflowId: DETERMINISTIC_WORKFLOW_ID,
      taskQueue: LEDGER_TASK_QUEUE,
      args: [WORKFLOW_INPUT],
    });

    startedWorkflowIds.push(handle.workflowId);
    expect(handle.workflowId).toBe(DETERMINISTIC_WORKFLOW_ID);
  });

  it("second start with same ID while first is running throws WorkflowExecutionAlreadyStartedError", async () => {
    const client = await getTestTemporalClient();

    // Start first workflow
    const handle1 = await client.workflow.start("CollectEpochWorkflow", {
      workflowId: DETERMINISTIC_WORKFLOW_ID,
      taskQueue: LEDGER_TASK_QUEUE,
      args: [WORKFLOW_INPUT],
    });
    startedWorkflowIds.push(handle1.workflowId);

    // Try to start second workflow with same ID — this is the "daily cron"
    // scenario where a second daily run fires for the same epoch window.
    //
    // Current behavior: Temporal rejects because workflow ID is already running.
    // This proves the bug from review feedback #1 — the deterministic ID
    // prevents multiple daily collections per epoch window.
    //
    // After the fix (include run date in ID, or use ID reuse policy),
    // this test should be updated to expect success.
    await expect(
      client.workflow.start("CollectEpochWorkflow", {
        workflowId: DETERMINISTIC_WORKFLOW_ID,
        taskQueue: LEDGER_TASK_QUEUE,
        args: [WORKFLOW_INPUT],
      })
    ).rejects.toThrow(WorkflowExecutionAlreadyStartedError);
  });

  it("workflow with unique per-run ID succeeds multiple times", async () => {
    const client = await getTestTemporalClient();

    // This tests the FIXED pattern: include run date in workflow ID
    const runDate1 = "2026-02-18";
    const runDate2 = "2026-02-19";
    const id1 = `${DETERMINISTIC_WORKFLOW_ID}-${runDate1}`;
    const id2 = `${DETERMINISTIC_WORKFLOW_ID}-${runDate2}`;

    const handle1 = await client.workflow.start("CollectEpochWorkflow", {
      workflowId: id1,
      taskQueue: LEDGER_TASK_QUEUE,
      args: [WORKFLOW_INPUT],
    });
    startedWorkflowIds.push(handle1.workflowId);

    const handle2 = await client.workflow.start("CollectEpochWorkflow", {
      workflowId: id2,
      taskQueue: LEDGER_TASK_QUEUE,
      args: [WORKFLOW_INPUT],
    });
    startedWorkflowIds.push(handle2.workflowId);

    // Both should start successfully with unique IDs
    expect(handle1.workflowId).toBe(id1);
    expect(handle2.workflowId).toBe(id2);
  });
});
