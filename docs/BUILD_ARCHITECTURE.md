# Build Architecture

> Scope: How the monorepo builds locally and in Docker. Critical knowledge for debugging build failures.

## Structure

```
cogni-template/          # Workspace root (Next.js app)
├── packages/
│   ├── aragon-osx/      # @cogni/aragon-osx (tsup → dist/)
│   └── cogni-contracts/ # @cogni/cogni-contracts (tsup → dist/)
└── pnpm-workspace.yaml  # Declares packages/* as workspace members
```

## Build Order

Workspace packages must build **before** the app because their exports point to `dist/`:

```
1. packages/*  →  tsup              →  dist/index.js (bundled JS)
2. root        →  tsc -b            →  dist/*.d.ts (per-file declarations via project references)
3. root        →  packages:validate →  verify declarations exist
4. root app    →  next build        →  .next/standalone
```

**Why three-phase package build:** tsup bundles JS; `tsc -b` from root emits per-file declarations; `packages:validate` verifies all declarations exist. The canonical command `pnpm packages:build` runs all three phases atomically.

## Local Build

```bash
pnpm packages:build    # Build workspace packages (tsup JS + tsc -b declarations)
pnpm -w build          # Build Next.js app (workspace root)
```

## Docker Build

The Dockerfile uses a single `builder` stage with manifest-first layering for optimal caching:

```dockerfile
# syntax=docker/dockerfile:1.7-labs

# 1. Copy dependency manifests first (maximizes install layer caching)
COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
COPY --parents packages/*/package.json ./

# 2. Install (cached when manifests unchanged)
pnpm install --frozen-lockfile

# 3. Copy source
COPY . .

# 4. Build all packages using canonical command (tsup + tsc -b + validation)
pnpm packages:build

# 5. Build workspace root
pnpm -w build
```

**Why manifest-first:** Copying dependency manifests before `pnpm install` ensures the install layer is cached when only source files change. The `--parents` flag (requires `1.7-labs` syntax) preserves directory structure for workspace package manifests.

**Why canonical command:** `pnpm packages:build` is the single source of truth for package builds. It runs tsup (JS), tsc -b (declarations), and validation atomically. The same command is used in local dev, CI, and Docker builds.

## Critical Details

### Package Exports Require dist/

```json
// packages/*/package.json
"exports": {
  ".": {
    "types": "./dist/index.d.ts",
    "import": "./dist/index.js"
  }
}
```

If `dist/` doesn't exist, Next.js build fails with module resolution errors.

### Declaration Generation

Package tsconfigs use `composite: true` for project references. Declarations are generated by `tsc -b` from root (not tsup):

```typescript
// packages/*/tsup.config.ts
dts: false,  // tsc -b handles declarations via project references
```

**Important:** Never add `tsc -b` to individual package build scripts. Always run it from root to ensure the full reference graph is built correctly.

### Declaration Validation

After `tsc -b` runs, `pnpm packages:validate` verifies that all declarations exist. This is data-driven:

1. Reads `tsconfig.json` references to discover packages
2. For each package, reads `package.json` exports["."].types
3. Verifies that file exists

No hardcoded package names — new packages are automatically validated when added to `tsconfig.json` references.

### TypeScript Configuration

Five tsconfigs exist for different scenarios:

| Config                  | Command               | Includes               | Use Case                               |
| ----------------------- | --------------------- | ---------------------- | -------------------------------------- |
| `tsconfig.base.json`    | N/A                   | None (options only)    | Shared compiler options + path aliases |
| `tsconfig.json`         | `pnpm typecheck:full` | None (solution-style)  | `tsc -b` with project references       |
| `tsconfig.app.json`     | `pnpm typecheck`      | `src/`                 | Fast app typecheck (no packages)       |
| `tsconfig.scripts.json` | N/A (tsx uses it)     | `scripts/`             | tsx tooling path resolution            |
| `tsconfig.eslint.json`  | N/A (ESLint uses it)  | `src/`, `tests/`, root | ESLint parser                          |

**Why solution-style root**: `tsconfig.json` contains only `references` (no `include`). This prevents the "mixed-mode" anti-pattern where package sources are both directly included AND referenced, causing TS6305 errors in Docker builds.

**Why separate configs**: Each tool (tsc, tsx, ESLint) needs path aliases but has different scope requirements. Shared options live in `tsconfig.base.json`; tool-specific configs extend it.

## Known Issues

| Issue                         | Impact                                                 | Workaround                                                                 |
| ----------------------------- | ------------------------------------------------------ | -------------------------------------------------------------------------- |
| Build not graph-scoped        | Builds all packages even if app doesn't depend on them | Acceptable for 2 packages; revisit with turbo prune if package count grows |
| AUTH_SECRET required at build | Next.js page collection triggers env validation        | Dockerfile sets placeholder; runtime must provide real value               |

## Future Improvements

1. **Graph-scoped builds**: Adopt `turbo prune --docker` or `pnpm deploy` for minimal build context
2. **Runtime-only env validation**: Remove build-time env coupling by checking `NEXT_PHASE` or deferring validation
3. **App as workspace package**: Move app to `apps/web` for proper filter targeting (`pnpm --filter web... build`)
