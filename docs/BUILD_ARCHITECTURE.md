# Build Architecture

> Scope: How the monorepo builds locally and in Docker. Critical knowledge for debugging build failures.

## Structure

```
cogni-template/          # Workspace root (Next.js app)
├── packages/
│   ├── aragon-osx/      # @cogni/aragon-osx (tsup → dist/)
│   └── cogni-contracts/ # @cogni/cogni-contracts (tsup → dist/)
└── pnpm-workspace.yaml  # Declares packages/* as workspace members
```

## Build Order

Workspace packages must build **before** the app because their exports point to `dist/`:

```
1. packages/*  →  tsup        →  dist/index.js (bundled JS)
2. root        →  tsc -b      →  dist/*.d.ts (per-file declarations via project references)
3. root app    →  next build  →  .next/standalone
```

**Why two-phase package build:** tsup bundles JS; `tsc -b` from root emits per-file declarations using TypeScript project references. This separation ensures `tsc -b` validates the full type graph correctly.

## Local Build

```bash
pnpm packages:build    # Build workspace packages (tsup JS + tsc -b declarations)
pnpm -w build          # Build Next.js app (workspace root)
```

## Docker Build

The Dockerfile uses a single `builder` stage:

```dockerfile
COPY . .
pnpm install --frozen-lockfile

# 1. Build all packages: tsup for JS, tsc -b for declarations
pnpm -r --filter "./packages/**" build && pnpm exec tsc -b

# 2. Build workspace root
pnpm -w build
```

**Why three steps:** tsup bundles JS for each package, `tsc -b` from root emits per-file declarations via project references, then Next.js builds the app.

## Critical Details

### Package Exports Require dist/

```json
// packages/*/package.json
"exports": {
  ".": {
    "types": "./dist/index.d.ts",
    "import": "./dist/index.js"
  }
}
```

If `dist/` doesn't exist, Next.js build fails with module resolution errors.

### Declaration Generation

Package tsconfigs use `composite: true` for project references. Declarations are generated by `tsc -b` from root (not tsup):

```typescript
// packages/*/tsup.config.ts
dts: false,  // tsc -b handles declarations via project references
```

**Important:** Never add `tsc -b` to individual package build scripts. Always run it from root to ensure the full reference graph is built correctly.

### Fast vs Full Typecheck

Two tsconfigs exist for different scenarios:

| Config              | Command               | Includes                | Use Case                         |
| ------------------- | --------------------- | ----------------------- | -------------------------------- |
| `tsconfig.app.json` | `pnpm typecheck`      | `src/`, `scripts/` only | Fast checks (no packages needed) |
| `tsconfig.json`     | `pnpm typecheck:full` | Everything via `tsc -b` | Full build (packages must exist) |

**Why**: Root tsconfig uses project references to packages. Running `tsc --noEmit` on it requires `dist/` to exist (TS6305). The app-only config sidesteps this for fast iteration.

## Known Issues

| Issue                         | Impact                                                 | Workaround                                                                 |
| ----------------------------- | ------------------------------------------------------ | -------------------------------------------------------------------------- |
| Build not graph-scoped        | Builds all packages even if app doesn't depend on them | Acceptable for 2 packages; revisit with turbo prune if package count grows |
| AUTH_SECRET required at build | Next.js page collection triggers env validation        | Dockerfile sets placeholder; runtime must provide real value               |

## Future Improvements

1. **Graph-scoped builds**: Adopt `turbo prune --docker` or `pnpm deploy` for minimal build context
2. **Runtime-only env validation**: Remove build-time env coupling by checking `NEXT_PHASE` or deferring validation
3. **App as workspace package**: Move app to `apps/web` for proper filter targeting (`pnpm --filter web... build`)
