# Build Architecture

> Scope: How the monorepo builds locally and in Docker. Critical knowledge for debugging build failures.

## Structure

```
cogni-template/          # Workspace root (Next.js app)
├── packages/
│   ├── aragon-osx/      # @cogni/aragon-osx (tsup → dist/)
│   └── cogni-contracts/ # @cogni/cogni-contracts (tsup → dist/)
└── pnpm-workspace.yaml  # Declares packages/* as workspace members
```

## Build Order

Workspace packages must build **before** the app because their exports point to `dist/`:

```
1. packages/*  →  tsup        →  dist/index.js (bundled JS)
2. root        →  tsc -b      →  dist/*.d.ts (per-file declarations via project references)
3. root app    →  next build  →  .next/standalone
```

**Why two-phase package build:** tsup bundles JS; `tsc -b` from root emits per-file declarations using TypeScript project references. This separation ensures `tsc -b` validates the full type graph correctly.

## Local Build

```bash
pnpm packages:build    # Build workspace packages (tsup JS + tsc -b declarations)
pnpm -w build          # Build Next.js app (workspace root)
```

## Docker Build

The Dockerfile uses a single `builder` stage:

```dockerfile
COPY . .
pnpm install --frozen-lockfile

# 1. Build all packages: tsup for JS, tsc -b for declarations
pnpm -r --filter "./packages/**" build && pnpm exec tsc -b

# 2. Build workspace root
pnpm -w build
```

**Why three steps:** tsup bundles JS for each package, `tsc -b` from root emits per-file declarations via project references, then Next.js builds the app.

## Critical Details

### Package Exports Require dist/

```json
// packages/*/package.json
"exports": {
  ".": {
    "types": "./dist/index.d.ts",
    "import": "./dist/index.js"
  }
}
```

If `dist/` doesn't exist, Next.js build fails with module resolution errors.

### Declaration Generation

Package tsconfigs use `composite: true` for project references. Declarations are generated by `tsc -b` from root (not tsup):

```typescript
// packages/*/tsup.config.ts
dts: false,  // tsc -b handles declarations via project references
```

**Important:** Never add `tsc -b` to individual package build scripts. Always run it from root to ensure the full reference graph is built correctly.

### TypeScript Configuration

Five tsconfigs exist for different scenarios:

| Config                  | Command               | Includes               | Use Case                               |
| ----------------------- | --------------------- | ---------------------- | -------------------------------------- |
| `tsconfig.base.json`    | N/A                   | None (options only)    | Shared compiler options + path aliases |
| `tsconfig.json`         | `pnpm typecheck:full` | None (solution-style)  | `tsc -b` with project references       |
| `tsconfig.app.json`     | `pnpm typecheck`      | `src/`, `scripts/`     | Fast app typecheck (no packages)       |
| `tsconfig.scripts.json` | N/A (tsx uses it)     | `scripts/`             | tsx tooling path resolution            |
| `tsconfig.eslint.json`  | N/A (ESLint uses it)  | `src/`, `tests/`, root | ESLint parser                          |

**Why solution-style root**: `tsconfig.json` contains only `references` (no `include`). This prevents the "mixed-mode" anti-pattern where package sources are both directly included AND referenced, causing TS6305 errors in Docker builds.

**Why separate configs**: Each tool (tsc, tsx, ESLint) needs path aliases but has different scope requirements. Shared options live in `tsconfig.base.json`; tool-specific configs extend it.

## Known Issues

| Issue                         | Impact                                                 | Workaround                                                                 |
| ----------------------------- | ------------------------------------------------------ | -------------------------------------------------------------------------- |
| Build not graph-scoped        | Builds all packages even if app doesn't depend on them | Acceptable for 2 packages; revisit with turbo prune if package count grows |
| AUTH_SECRET required at build | Next.js page collection triggers env validation        | Dockerfile sets placeholder; runtime must provide real value               |

## Future Improvements

1. **Graph-scoped builds**: Adopt `turbo prune --docker` or `pnpm deploy` for minimal build context
2. **Runtime-only env validation**: Remove build-time env coupling by checking `NEXT_PHASE` or deferring validation
3. **App as workspace package**: Move app to `apps/web` for proper filter targeting (`pnpm --filter web... build`)
