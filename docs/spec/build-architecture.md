---
id: build-architecture-spec
type: spec
title: Build Architecture
status: active
spec_state: draft
trust: draft
summary: How the monorepo builds locally and in Docker — package build order, declaration generation, and layer caching.
read_when: Debugging build failures, modifying Dockerfile, or adding workspace packages.
owner: derekg1729
created: 2026-02-06
verified: 2026-02-06
tags: [deployment]
---

# Build Architecture

## Context

The monorepo contains workspace packages whose exports point to `dist/`. These must build before the Next.js app. Understanding the build pipeline is critical for debugging build failures in local dev, CI, and Docker.

## Goal

Provide a deterministic, cacheable build pipeline where workspace packages build atomically via a single canonical command, and Docker builds use manifest-first layering for optimal caching.

## Non-Goals

- Graph-scoped builds with turbo prune (deferred, tracked in ini.cicd-services-gitops.md)
- Runtime-only env validation (deferred)
- Moving app to `apps/web` workspace package (deferred)

## Core Invariants

1. **PACKAGES_BUILD_BEFORE_APP**: Workspace packages must build before the app because their `package.json` exports point to `dist/`. If `dist/` doesn't exist, Next.js build fails with module resolution errors.

2. **CANONICAL_BUILD_COMMAND**: `pnpm packages:build` is the single source of truth for package builds. It runs tsup (JS), tsc -b (declarations), and validation atomically. The same command is used in local dev, CI, and Docker builds.

3. **TSC_B_FROM_ROOT_ONLY**: Declarations are generated by `tsc -b` from root (not tsup, not individual package scripts). Never add `tsc -b` to individual package build scripts — always run from root to ensure the full reference graph is built correctly.

4. **SOLUTION_STYLE_ROOT_TSCONFIG**: `tsconfig.json` contains only `references` (no `include`). This prevents the "mixed-mode" anti-pattern where package sources are both directly included AND referenced, causing TS6305 errors in Docker builds.

5. **DATA_DRIVEN_VALIDATION**: `pnpm packages:validate` discovers packages from `tsconfig.json` references and verifies declarations exist. No hardcoded package names — new packages are automatically validated.

## Design

### Monorepo Structure

```
cogni-template/          # Workspace root (Next.js app)
├── packages/
│   ├── aragon-osx/      # @cogni/aragon-osx (tsup → dist/)
│   └── cogni-contracts/ # @cogni/cogni-contracts (tsup → dist/)
└── pnpm-workspace.yaml  # Declares packages/* as workspace members
```

### Build Order

```
1. packages/*  →  tsup              →  dist/index.js (bundled JS)
2. root        →  tsc -b            →  dist/*.d.ts (per-file declarations via project references)
3. root        →  packages:validate →  verify declarations exist
4. root app    →  next build        →  .next/standalone
```

**Why three-phase package build:** tsup bundles JS; `tsc -b` from root emits per-file declarations; `packages:validate` verifies all declarations exist.

### Local Build

```bash
pnpm packages:build    # Build workspace packages (tsup JS + tsc -b declarations)
pnpm -w build          # Build Next.js app (workspace root)
```

### Docker Build

The Dockerfile uses a single `builder` stage with manifest-first layering for optimal caching:

```dockerfile
# syntax=docker/dockerfile:1.7-labs

# 1. Copy dependency manifests first (maximizes install layer caching)
COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
COPY --parents packages/*/package.json ./

# 2. Install (cached when manifests unchanged)
pnpm install --frozen-lockfile

# 3. Copy source
COPY . .

# 4. Build all packages using canonical command (tsup + tsc -b + validation)
pnpm packages:build

# 5. Build workspace root
pnpm -w build
```

**Why manifest-first:** Copying dependency manifests before `pnpm install` ensures the install layer is cached when only source files change. The `--parents` flag (requires `1.7-labs` syntax) preserves directory structure for workspace package manifests.

### Package Exports Require dist/

```json
// packages/*/package.json
"exports": {
  ".": {
    "types": "./dist/index.d.ts",
    "import": "./dist/index.js"
  }
}
```

### Declaration Generation

Package tsconfigs use `composite: true` for project references. Declarations are generated by `tsc -b` from root (not tsup):

```typescript
// packages/*/tsup.config.ts
dts: false,  // tsc -b handles declarations via project references
```

### Declaration Validation

After `tsc -b` runs, `pnpm packages:validate` verifies that all declarations exist. This is data-driven:

1. Reads `tsconfig.json` references to discover packages
2. For each package, reads `package.json` exports["."].types
3. Verifies that file exists

### TypeScript Configuration

Five tsconfigs exist for different scenarios:

| Config                  | Command               | Includes               | Use Case                               |
| ----------------------- | --------------------- | ---------------------- | -------------------------------------- |
| `tsconfig.base.json`    | N/A                   | None (options only)    | Shared compiler options + path aliases |
| `tsconfig.json`         | `pnpm typecheck:full` | None (solution-style)  | `tsc -b` with project references       |
| `tsconfig.app.json`     | `pnpm typecheck`      | `src/`                 | Fast app typecheck (no packages)       |
| `tsconfig.scripts.json` | N/A (tsx uses it)     | `scripts/`             | tsx tooling path resolution            |
| `tsconfig.eslint.json`  | N/A (ESLint uses it)  | `src/`, `tests/`, root | ESLint parser                          |

**Why solution-style root**: Prevents the "mixed-mode" anti-pattern causing TS6305 errors in Docker builds.

**Why separate configs**: Each tool (tsc, tsx, ESLint) needs path aliases but has different scope requirements. Shared options live in `tsconfig.base.json`; tool-specific configs extend it.

### Known Issues

| Issue                         | Impact                                                 | Workaround                                                                 |
| ----------------------------- | ------------------------------------------------------ | -------------------------------------------------------------------------- |
| Build not graph-scoped        | Builds all packages even if app doesn't depend on them | Acceptable for 2 packages; revisit with turbo prune if package count grows |
| AUTH_SECRET required at build | Next.js page collection triggers env validation        | Dockerfile sets placeholder; runtime must provide real value               |

### File Pointers

| File                        | Purpose                                       |
| --------------------------- | --------------------------------------------- |
| `Dockerfile`                | Multi-stage build with manifest-first caching |
| `pnpm-workspace.yaml`       | Workspace member declarations                 |
| `tsconfig.json`             | Solution-style root (references only)         |
| `tsconfig.base.json`        | Shared compiler options + path aliases        |
| `tsconfig.app.json`         | Fast app typecheck scope                      |
| `packages/*/tsup.config.ts` | Package JS bundling (dts: false)              |

## Acceptance Checks

**Automated:**

- `pnpm packages:build` — builds all workspace packages atomically
- `pnpm -w build` — builds Next.js app (fails if packages not built first)

**Manual:**

1. Verify `dist/index.d.ts` exists for each package after `pnpm packages:build`
2. Verify Docker build succeeds with `docker build .`

## Open Questions

_(none — future improvements tracked in ini.cicd-services-gitops.md: graph-scoped builds, runtime-only env validation, app-as-workspace-package)_

## Related

- [CI/CD](./ci-cd.md)
- [check:full](./check-full.md)
