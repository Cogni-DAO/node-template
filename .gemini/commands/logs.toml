# .gemini/commands/logs.toml
description = "Collect and analyze logs for the problem at hand"
prompt = """
It's time to collect and analyze logs for the problem at hand.

Use current context to infer the environment, or get user input: #$PROBLEM

NOTE: you do not currently have access to the MCP. please directly use the local url

Follow this systematic approach:

## 1. Identify the Environment

Ask the user which environment to investigate, or infer from context:

- **local** - User is running `pnpm docker:stack` (app containerized)
- **preview** - Staging/PR environment
- **production** - Live production

**MCP Server Selection:**

- Local: Use MCP tools for `graphana-local`
- Preview/Production: Use MCP tools for `graphana` (cloud)

**Important:** `dev:stack` does NOT collect app logs, only other services (app runs outside Docker). Only `docker:stack` collects all logs locally.

### CI Logs (GitHub Actions)

For CI failures, use `env="ci"`:

```logql
# All CI logs
{app="cogni-template", env="ci"}

# Specific workflow (e.g., "CI", "Staging Preview")
{app="cogni-template", env="ci", workflow="CI"}

# Specific job (e.g., "stack-test", "build-image")
{app="cogni-template", env="ci", job="stack-test"}

# Specific run (find run_id in GitHub Actions URL)
{app="cogni-template", env="ci", run_id="12345678901"}
```

**Available labels:** `workflow`, `job`, `ref`, `run_id`, `attempt`, `sha8`

## 2. Discover Available Data

1. **List datasources** to get UID:

   ```
   list_datasources(type: "loki")
   ```

2. **List available services:**

   ```
   list_loki_label_values(datasourceUid, labelName: "service")
   ```

   Expected: `app`, `litellm`, `caddy`, `deployment`

3. **List all queryable labels:**
   ```
   list_loki_label_names(datasourceUid)
   ```

**Our Configured Labels (indexed, low-cardinality):**

- `app` - Always "cogni-template"
- `env` - Environment: local | preview | production | ci
- `service` - Service name: app | litellm | caddy | deployment (runtime only, not CI)
- `stream` - stdout | stderr (runtime only, not CI)

**CI-specific labels** (when `env="ci"`):
- `workflow` - GitHub workflow name
- `job` - Job name
- `ref` - Branch/tag name
- `run_id` - GitHub run ID
- `attempt` - Retry attempt
- `sha8` - 8-char commit SHA

**JSON Fields (queryable via `| json`):**

- `reqId` - Request ID for tracing
- `userId` - User identifier
- `billingAccountId` - Billing account
- `level` - trace | debug | info | warn | error
- `msg` - Log message
- `time` - ISO8601 timestamp
- `event` - Domain event (e.g., "ai.llm_call", "payments.intent_created")
- `durationMs` - Request/operation duration
- `errorCode` - Stable error identifier

## 3. Collect Relevant Logs

Focus queries based on the problem. Use appropriate LogQL:

**For errors:**

```
{service="app", env="<env>"} | json | level="error"
{service="app", env="<env>"} |~ "(?i)(error|exception|failed)"
```

**For specific request:**

```
{service="app", env="<env>"} | json | reqId="<id>"
```

**For domain events:**

```
{service="app", env="<env>"} | json | event="payments.intent_created"
```

**Time range:** Default 1 hour. Use `startRfc3339`/`endRfc3339` for custom ranges.

## 4. Synthesize and Analyze

After collecting logs, provide:

1. **Key Errors:** Distinct error messages/codes with occurrence counts
2. **Root Cause Hypotheses:** Ranked by likelihood based on log evidence
3. **Affected Scope:** Time range, request count, user impact
4. **Pattern Analysis:** Common error patterns, timing issues, request flow problems
5. **Next Steps:** Investigation recommendations or reproduction steps

## UI Access (Optional)

- Local: http://localhost:3001
- Cloud: https://<your-org>.grafana.net
"""
